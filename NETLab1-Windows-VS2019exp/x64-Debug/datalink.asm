; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__F32AA0BD_concurrencysal@h DB 01H
__5A3A63C4_sal@h DB 01H
__6BEC7B3D_vadefs@h DB 01H
__1BC54112_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__4041E9ED_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__273EAB94_stdarg@h DB 01H
__A9062FA3_lprintf@h DB 01H
__4F65EB93_protocol@h DB 01H
__918D314E_datalink@h DB 01H
__065FE8C6_datalink@c DB 01H
msvcjmc	ENDS
PUBLIC	main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0DI@CLMIKCHA@Designed?5by?5Zheng?5Yuheng?0?5build@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BC@LHEMAHKM@Recv?5NAK?5DATA?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ ; `string'
PUBLIC	??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@		; `string'
EXTRN	memcpy:PROC
EXTRN	lprintf:PROC
EXTRN	protocol_init:PROC
EXTRN	wait_for_event:PROC
EXTRN	enable_network_layer:PROC
EXTRN	disable_network_layer:PROC
EXTRN	get_packet:PROC
EXTRN	put_packet:PROC
EXTRN	recv_frame:PROC
EXTRN	send_frame:PROC
EXTRN	crc32:PROC
EXTRN	start_timer:PROC
EXTRN	stop_timer:PROC
EXTRN	start_ack_timer:PROC
EXTRN	stop_ack_timer:PROC
EXTRN	dbg_event:PROC
EXTRN	dbg_frame:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
phl_ready DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$between DD imagerel between
	DD	imagerel between+161
	DD	imagerel $unwind$between
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$put_frame DD imagerel put_frame
	DD	imagerel put_frame+113
	DD	imagerel $unwind$put_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_data DD imagerel send_data
	DD	imagerel send_data+408
	DD	imagerel $unwind$send_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN32
	DD	imagerel $LN32+1436
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@ DB 'Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Send DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ DB '---- DATA %d tim'
	DB	'eout', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LHEMAHKM@Recv?5NAK?5DATA?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@LHEMAHKM@Recv?5NAK?5DATA?5?$CFd?6@ DB 'Recv NAK DATA %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CLMIKCHA@Designed?5by?5Zheng?5Yuheng?0?5build@
CONST	SEGMENT
??_C@_0DI@CLMIKCHA@Designed?5by?5Zheng?5Yuheng?0?5build@ DB 'Designed by '
	DB	'Zheng Yuheng, build: May  2 2022  22:07:41', 0aH, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
no_nak	DD	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	0583H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025054619H
	DD	0118231dH
	DD	0700b051fH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	028e8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 06fH
	DB	075H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
main$rtcName$1 DB 069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+1
main$rtcName$2 DB 061H
	DB	072H
	DB	072H
	DB	069H
	DB	076H
	DB	065H
	DB	064H
	DB	00H
main$rtcName$3 DB 061H
	DB	072H
	DB	067H
	DB	00H
main$rtcName$4 DB 066H
	DB	00H
	ORG $+2
main$rtcVarDesc DD 021b0H
	DD	0108H
	DQ	FLAT:main$rtcName$4
	DD	02184H
	DD	04H
	DQ	FLAT:main$rtcName$3
	DD	02110H
	DD	040H
	DQ	FLAT:main$rtcName$2
	DD	010f0H
	DD	01000H
	DQ	FLAT:main$rtcName$1
	DD	0d0H
	DD	01000H
	DQ	FLAT:main$rtcName$0
	ORG $+240
main$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	043H
	DW	017fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_data DD 025054a19H
	DD	011b2320H
	DD	070140043H
	DD	05013H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
send_data$rtcName$0 DB 073H
	DB	00H
	ORG $+14
send_data$rtcVarDesc DD 030H
	DD	0108H
	DQ	FLAT:send_data$rtcName$0
	ORG $+48
send_data$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:send_data$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$put_frame DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$between DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\datalink.c
;	COMDAT main
_TEXT	SEGMENT
ack_expected$ = 4
next_frame_to_send$ = 36
too_far$ = 68
frame_expected$ = 100
nbuffered$ = 132
out_buf$ = 176
in_buf$ = 4304
arrived$ = 8432
event$ = 8516
arg$ = 8548
f$ = 8592
len$ = 8884
tv241 = 10436
tv216 = 10436
tv191 = 10436
tv156 = 10436
tv73 = 10436
__$ArrayPad$ = 10440
argc$ = 10480
argv$ = 10488
main	PROC						; COMDAT

; 41   : {

$LN32:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	mov	eax, 10488				; 000028f8H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 2230				; 000008b6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+10520]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__065FE8C6_datalink@c
	call	__CheckForDebuggerJustMyCode

; 42   :     unsigned char ack_expected = 0;         //发送窗口下界

	mov	BYTE PTR ack_expected$[rbp], 0

; 43   :     unsigned char next_frame_to_send = 0;   //发送窗口上界

	mov	BYTE PTR next_frame_to_send$[rbp], 0

; 44   :     unsigned char too_far = NR_BUFS;        //接收窗口上界

	mov	BYTE PTR too_far$[rbp], 16

; 45   :     unsigned char frame_expected = 0;       //接收窗口下界

	mov	BYTE PTR frame_expected$[rbp], 0

; 46   :     unsigned char nbuffered = 0;            //计数，发送了几个帧

	mov	BYTE PTR nbuffered$[rbp], 0

; 47   :     Packet out_buf[NR_BUFS];                //输出流缓冲区
; 48   :     Packet in_buf[NR_BUFS];                 //输入流缓冲区
; 49   :     bool arrived[NR_BUFS] = { false };      //表示输入流缓冲区是否空闲

	lea	rax, QWORD PTR arrived$[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 64					; 00000040H
	rep stosb

; 50   : 
; 51   :     int event;      //系统事件
; 52   :     int arg;        //需要重传的帧的序列号
; 53   :     Frame f;        //暂存帧
; 54   :     int len = 0;    //接收的帧的长度

	mov	DWORD PTR len$[rbp], 0

; 55   : 
; 56   :     //初始化
; 57   :     enable_network_layer();

	call	enable_network_layer

; 58   :     protocol_init(argc, argv);

	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	protocol_init

; 59   :     lprintf("Designed by Zheng Yuheng, build: " __DATE__"  "__TIME__"\n");

	lea	rcx, OFFSET FLAT:??_C@_0DI@CLMIKCHA@Designed?5by?5Zheng?5Yuheng?0?5build@
	call	lprintf
$LN2@main:

; 60   : 
; 61   :     for (;;) {
; 62   :         //获取系统事件。如果是数据帧超时需要重传，arg将存储需要重传的数据帧序列号。
; 63   :         event = wait_for_event(&arg);   

	lea	rcx, QWORD PTR arg$[rbp]
	call	wait_for_event
	mov	DWORD PTR event$[rbp], eax

; 64   : 
; 65   :         switch (event) {

	mov	eax, DWORD PTR event$[rbp]
	mov	DWORD PTR tv73[rbp], eax
	cmp	DWORD PTR tv73[rbp], 0
	je	SHORT $LN11@main
	cmp	DWORD PTR tv73[rbp], 1
	je	$LN12@main
	cmp	DWORD PTR tv73[rbp], 2
	je	$LN13@main
	cmp	DWORD PTR tv73[rbp], 3
	je	$LN25@main
	cmp	DWORD PTR tv73[rbp], 4
	je	$LN27@main
	jmp	$LN28@main
$LN11@main:

; 66   :         case NETWORK_LAYER_READY:   //网络层有数据发送
; 67   :             nbuffered++;            //输出流缓冲区内的帧+1

	movzx	eax, BYTE PTR nbuffered$[rbp]
	inc	al
	mov	BYTE PTR nbuffered$[rbp], al

; 68   :             get_packet(out_buf[next_frame_to_send % NR_BUFS]);                  //从网络层获取帧

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR out_buf$[rbp+rax]
	mov	rcx, rax
	call	get_packet

; 69   :             send_data(FRAME_DATA, next_frame_to_send, frame_expected, out_buf); //发送帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR next_frame_to_send$[rbp]
	mov	cl, 1
	call	send_data

; 70   :             inc(next_frame_to_send);    //更新发送窗口上界

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR next_frame_to_send$[rbp], al

; 71   :             break;

	jmp	$LN5@main
$LN12@main:

; 72   : 
; 73   :         case PHYSICAL_LAYER_READY:  //物理层可传送数据
; 74   :             phl_ready = true;

	mov	DWORD PTR phl_ready, 1

; 75   :             break;

	jmp	$LN5@main
$LN13@main:

; 76   : 
; 77   :         case FRAME_RECEIVED:        //收到帧
; 78   :             len = recv_frame((unsigned char*)&f, sizeof f);     //从物理层获取帧。帧长度存储在len。

	mov	edx, 264				; 00000108H
	lea	rcx, QWORD PTR f$[rbp]
	call	recv_frame
	mov	DWORD PTR len$[rbp], eax

; 79   :             if (len < 5 || crc32((unsigned char*)&f, len) != 0) //检查帧长度是否正常，且能否通过CRC校验

	cmp	DWORD PTR len$[rbp], 5
	jl	SHORT $LN15@main
	mov	edx, DWORD PTR len$[rbp]
	lea	rcx, QWORD PTR f$[rbp]
	call	crc32
	test	eax, eax
	je	SHORT $LN14@main
$LN15@main:

; 80   :             {
; 81   :                 dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	lea	rcx, OFFSET FLAT:??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	dbg_event

; 82   :                 if (no_nak) //之前没发送过NAK帧才能发送NAK帧

	cmp	DWORD PTR no_nak, 0
	je	SHORT $LN16@main

; 83   :                     send_data(FRAME_NAK, 0, frame_expected, out_buf);   //发送NAK帧要求重传

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send_data
$LN16@main:

; 84   :                 break;

	jmp	$LN5@main
$LN14@main:

; 85   :             }
; 86   : 
; 87   :             if (f.kind == FRAME_ACK)        //收到ACK帧

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 2
	jne	SHORT $LN17@main

; 88   :                 dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	dbg_frame
	jmp	$LN18@main
$LN17@main:

; 89   :             else if (f.kind == FRAME_DATA)  //收到数据帧

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 1
	jne	$LN19@main

; 90   :             {
; 91   :                 if (f.seq != frame_expected && no_nak)  //如果不等于接收窗口下界且没有发送过NAK帧，发送NAK帧要求重传

	movzx	eax, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	cmp	eax, ecx
	je	SHORT $LN21@main
	cmp	DWORD PTR no_nak, 0
	je	SHORT $LN21@main

; 92   :                     send_data(FRAME_NAK, 0, frame_expected, out_buf);

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send_data
	jmp	SHORT $LN22@main
$LN21@main:

; 93   :                 else
; 94   :                     start_ack_timer(ACK_TIMER);         //如没有反向流量，ACK无法捎带。定时结束后发送一个单独的ACK帧

	mov	ecx, 400				; 00000190H
	call	start_ack_timer
$LN22@main:

; 95   : 
; 96   :                 /*如果收到的帧序号在接收窗口内，且对应的输入缓冲区为空*/
; 97   :                 if (between(frame_expected, f.seq, too_far) && (arrived[f.seq % NR_BUFS] == false))

	movzx	eax, BYTE PTR too_far$[rbp]
	movzx	ecx, BYTE PTR f$[rbp+2]
	movzx	edx, BYTE PTR frame_expected$[rbp]
	mov	DWORD PTR tv156[rbp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv156[rbp]
	mov	ecx, eax
	call	between
	test	eax, eax
	je	$LN23@main
	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	cmp	DWORD PTR arrived$[rbp+rax*4], 0
	jne	$LN23@main

; 98   :                 {
; 99   :                     dbg_frame("Recv DATA %d %d, ID %d\n", f.seq, f.ack, *(short*)&(f.data));

	movsx	eax, WORD PTR f$[rbp+3]
	movzx	ecx, BYTE PTR f$[rbp+1]
	movzx	edx, BYTE PTR f$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame

; 100  :                     arrived[f.seq % NR_BUFS] = true;                    //标记缓冲区为满

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	DWORD PTR arrived$[rbp+rax*4], 1

; 101  :                     memcpy(in_buf[f.seq % NR_BUFS], f.data, PKT_LEN);   //将数据写入缓冲区

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	r8d, 256				; 00000100H
	lea	rdx, QWORD PTR f$[rbp+3]
	mov	rcx, rax
	call	memcpy
$LN7@main:

; 102  :                     while (arrived[frame_expected % NR_BUFS])           //将从接收窗口下界开始，所有不为空的缓冲区数据送往网络层

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	cmp	DWORD PTR arrived$[rbp+rax*4], 0
	je	$LN8@main

; 103  :                     {
; 104  :                         put_packet(in_buf[frame_expected % NR_BUFS], len - 7);  //将数据送往网络层

	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 7
	mov	DWORD PTR tv191[rbp], eax
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	ecx, DWORD PTR tv191[rbp]
	mov	edx, ecx
	mov	rcx, rax
	call	put_packet

; 105  :                         no_nak = true;

	mov	DWORD PTR no_nak, 1

; 106  :                         arrived[frame_expected % NR_BUFS] = false;      //标记缓冲区为空

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	DWORD PTR arrived$[rbp+rax*4], 0

; 107  :                         inc(frame_expected);        //更新接收窗口下界

	movzx	eax, BYTE PTR frame_expected$[rbp]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR frame_expected$[rbp], al

; 108  :                         inc(too_far);               //更新接收窗口上界

	movzx	eax, BYTE PTR too_far$[rbp]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR too_far$[rbp], al

; 109  :                         start_ack_timer(ACK_TIMER); //如没有反向流量，ACK无法捎带。定时结束后发送一个单独的ACK帧

	mov	ecx, 400				; 00000190H
	call	start_ack_timer

; 110  :                     }

	jmp	$LN7@main
$LN8@main:
$LN23@main:

; 111  :                 }
; 112  :             }

	jmp	$LN20@main
$LN19@main:

; 113  :             else if (f.kind == FRAME_NAK && between(ack_expected, (f.ack + 1) % (MAX_SEQ + 1), next_frame_to_send)) //收到NAK帧，NAK帧的序号在发送窗口内

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 3
	jne	SHORT $LN24@main
	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	mov	DWORD PTR tv216[rbp], eax
	movzx	ecx, BYTE PTR f$[rbp+1]
	inc	ecx
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	mov	edx, DWORD PTR tv216[rbp]
	mov	r8d, edx
	mov	edx, eax
	call	between
	test	eax, eax
	je	SHORT $LN24@main

; 114  :             {
; 115  :                 dbg_frame("Recv NAK DATA %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BC@LHEMAHKM@Recv?5NAK?5DATA?5?$CFd?6@
	call	dbg_frame

; 116  :                 send_data(FRAME_DATA, (f.ack + 1) % (MAX_SEQ + 1), frame_expected, out_buf);    //重传数据帧

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, al
	mov	cl, 1
	call	send_data
$LN24@main:
$LN20@main:
$LN18@main:
$LN9@main:

; 117  :             }
; 118  : 
; 119  :             while (between(ack_expected, f.ack, next_frame_to_send))    //检查ACK序号是否在发送窗口内

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	movzx	ecx, BYTE PTR f$[rbp+1]
	movzx	edx, BYTE PTR ack_expected$[rbp]
	mov	DWORD PTR tv241[rbp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv241[rbp]
	mov	ecx, eax
	call	between
	test	eax, eax
	je	SHORT $LN10@main

; 120  :             {
; 121  :                 nbuffered--;                        //输出流缓冲区内的帧-1

	movzx	eax, BYTE PTR nbuffered$[rbp]
	dec	al
	mov	BYTE PTR nbuffered$[rbp], al

; 122  :                 stop_timer(ack_expected % NR_BUFS); //收到ACK，停止数据帧重传定时器

	movzx	eax, BYTE PTR ack_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	mov	ecx, eax
	call	stop_timer

; 123  :                 inc(ack_expected);                  //更新发送窗口下界

	movzx	eax, BYTE PTR ack_expected$[rbp]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR ack_expected$[rbp], al

; 124  :             }

	jmp	SHORT $LN9@main
$LN10@main:

; 125  :             break;

	jmp	SHORT $LN5@main
$LN25@main:

; 126  : 
; 127  :         case DATA_TIMEOUT:      //数据超时，选择重传
; 128  :             dbg_event("---- DATA %d timeout\n", arg);

	mov	edx, DWORD PTR arg$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	dbg_event

; 129  :             if (!between(ack_expected, arg, next_frame_to_send))    //arg的取值范围在0-15，可能需要加NR_BUFS得到在发送窗口中正确的序号

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	mov	r8d, eax
	mov	edx, DWORD PTR arg$[rbp]
	call	between
	test	eax, eax
	jne	SHORT $LN26@main

; 130  :                 arg += NR_BUFS;

	mov	eax, DWORD PTR arg$[rbp]
	add	eax, 16
	mov	DWORD PTR arg$[rbp], eax
$LN26@main:

; 131  :             send_data(FRAME_DATA, arg, frame_expected, out_buf);    //重新发送数据

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR arg$[rbp]
	mov	cl, 1
	call	send_data

; 132  :             break;

	jmp	SHORT $LN5@main
$LN27@main:

; 133  : 
; 134  :         case ACK_TIMEOUT:       //ACK超时
; 135  :             dbg_event("---- DATA %d timeout\n", arg);

	mov	edx, DWORD PTR arg$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	dbg_event

; 136  :             send_data(FRAME_ACK, 0, frame_expected, out_buf);       //单独发送一个ACK帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 2
	call	send_data
$LN28@main:
$LN5@main:

; 137  :             break;
; 138  : 
; 139  :         default:
; 140  :             break;
; 141  :         }
; 142  : 
; 143  :         //缓冲区没满，继续发送
; 144  :         if (nbuffered < NR_BUFS && phl_ready)   

	movzx	eax, BYTE PTR nbuffered$[rbp]
	cmp	eax, 16
	jge	SHORT $LN29@main
	cmp	DWORD PTR phl_ready, 0
	je	SHORT $LN29@main

; 145  :             enable_network_layer();

	call	enable_network_layer
	jmp	SHORT $LN30@main
$LN29@main:

; 146  :         //缓冲区满，停止发送
; 147  :         else
; 148  :             disable_network_layer();

	call	disable_network_layer
$LN30@main:

; 149  :     }

	jmp	$LN2@main

; 150  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:main$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+10456]
	pop	rdi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\datalink.c
;	COMDAT send_data
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 488
fk$ = 528
frame_nr$ = 536
frame_expected$ = 544
buffer$ = 552
send_data PROC						; COMDAT

; 168  : {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 536				; 00000218H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+568]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__065FE8C6_datalink@c
	call	__CheckForDebuggerJustMyCode

; 169  :     Frame s;
; 170  : 
; 171  :     s.kind = fk;        //帧类型

	movzx	eax, BYTE PTR fk$[rbp]
	mov	BYTE PTR s$[rbp], al

; 172  :     s.seq = frame_nr;   //帧序号                                

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	BYTE PTR s$[rbp+2], al

; 173  :     s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1); //累计ACK，序号表示最后一个正确收到的帧

	movzx	eax, BYTE PTR frame_expected$[rbp]
	add	eax, 31
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR s$[rbp+1], al

; 174  :     if (fk == FRAME_DATA)       //发送数据帧

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 1
	jne	$LN2@send_data

; 175  :     {
; 176  :         memcpy(s.data, buffer[frame_nr % NR_BUFS], PKT_LEN);    //将缓冲区缓冲区复制到帧s中

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 256				; 00000100H
	mov	rdx, rax
	lea	rcx, QWORD PTR s$[rbp+3]
	call	memcpy

; 177  :         dbg_frame("Send DATA %d %d, ID %d\n", s.seq, s.ack, *(short*)&(s.data));    

	movsx	eax, WORD PTR s$[rbp+3]
	movzx	ecx, BYTE PTR s$[rbp+1]
	movzx	edx, BYTE PTR s$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame

; 178  :         put_frame((unsigned char*)&s, 3 + PKT_LEN);             //交往物理层

	mov	edx, 259				; 00000103H
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame

; 179  :         start_timer(frame_nr % NR_BUFS, DATA_TIMER);            //启动数据帧计时器

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	mov	edx, 4000				; 00000fa0H
	mov	ecx, eax
	call	start_timer

; 180  :     }

	jmp	SHORT $LN3@send_data
$LN2@send_data:

; 181  :     else if (fk == FRAME_ACK)   //发送ACK帧

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 2
	jne	SHORT $LN4@send_data

; 182  :     {
; 183  :         dbg_frame("Send ACK  %d\n", s.ack);

	movzx	eax, BYTE PTR s$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
	call	dbg_frame

; 184  :         put_frame((unsigned char*)&s, 2);   //交往物理层

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame

; 185  :     }   

	jmp	SHORT $LN5@send_data
$LN4@send_data:

; 186  :     else if (fk == FRAME_NAK)   //发送NAK帧

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 3
	jne	SHORT $LN6@send_data

; 187  :     {
; 188  :         no_nak = false;

	mov	DWORD PTR no_nak, 0

; 189  :         put_frame((unsigned char*)&s, 2);   //交往物理层

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
$LN6@send_data:
$LN5@send_data:
$LN3@send_data:

; 190  :     }
; 191  : 
; 192  :     stop_ack_timer();   //有反向流量，停止ACK计时器

	call	stop_ack_timer

; 193  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:send_data$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
send_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\datalink.c
;	COMDAT put_frame
_TEXT	SEGMENT
frame$ = 224
len$ = 232
put_frame PROC						; COMDAT

; 160  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__065FE8C6_datalink@c
	call	__CheckForDebuggerJustMyCode

; 161  :     *(unsigned int*)(frame + len) = crc32(frame, len);

	mov	edx, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	call	crc32
	movsxd	rcx, DWORD PTR len$[rbp]
	mov	rdx, QWORD PTR frame$[rbp]
	mov	DWORD PTR [rdx+rcx], eax

; 162  :     send_frame(frame, len + 4);

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 4
	mov	edx, eax
	mov	rcx, QWORD PTR frame$[rbp]
	call	send_frame

; 163  :     phl_ready = false;

	mov	DWORD PTR phl_ready, 0

; 164  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\datalink.c
;	COMDAT between
_TEXT	SEGMENT
tv70 = 192
a$ = 240
b$ = 248
c$ = 256
between	PROC						; COMDAT

; 154  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__065FE8C6_datalink@c
	call	__CheckForDebuggerJustMyCode

; 155  :     return ((a <= b) && (b < c)) || ((c < a) && (b >= a)) || ((c < a) && (b < c));

	mov	eax, DWORD PTR b$[rbp]
	cmp	DWORD PTR a$[rbp], eax
	ja	SHORT $LN3@between
	mov	eax, DWORD PTR c$[rbp]
	cmp	DWORD PTR b$[rbp], eax
	jb	SHORT $LN5@between
$LN3@between:
	mov	eax, DWORD PTR a$[rbp]
	cmp	DWORD PTR c$[rbp], eax
	jae	SHORT $LN4@between
	mov	eax, DWORD PTR a$[rbp]
	cmp	DWORD PTR b$[rbp], eax
	jae	SHORT $LN5@between
$LN4@between:
	mov	eax, DWORD PTR a$[rbp]
	cmp	DWORD PTR c$[rbp], eax
	jae	SHORT $LN6@between
	mov	eax, DWORD PTR c$[rbp]
	cmp	DWORD PTR b$[rbp], eax
	jb	SHORT $LN5@between
$LN6@between:
	mov	DWORD PTR tv70[rbp], 0
	jmp	SHORT $LN7@between
$LN5@between:
	mov	DWORD PTR tv70[rbp], 1
$LN7@between:
	mov	eax, DWORD PTR tv70[rbp]

; 156  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
between	ENDP
_TEXT	ENDS
END
