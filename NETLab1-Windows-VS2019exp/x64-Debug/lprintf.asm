; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	log_file
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
_BSS	SEGMENT
log_file DQ	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__F32AA0BD_concurrencysal@h DB 01H
__5A3A63C4_sal@h DB 01H
__6BEC7B3D_vadefs@h DB 01H
__1BC54112_vcruntime@h DB 01H
__AF2AD727_excpt@h DB 01H
__273EAB94_stdarg@h DB 01H
__1C9F390F_specstrings_undef@h DB 01H
__36A21E95_specstrings_strict@h DB 01H
__452FE810_sdv_driverspecs@h DB 01H
__30F344B3_driverspecs@h DB 01H
__BD886E18_specstrings@h DB 01H
__6569C2CA_corecrt@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__B2D2BA86_ctype@h DB 01H
__BF9C347F_kernelspecs@h DB 01H
__79C7FC57_basetsd@h DB 01H
__CDDAF8CA_errno@h DB 01H
__4041E9ED_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__DF4F952E_pshpack4@h DB 01H
__7FCD0577_poppack@h DB 01H
__DBC2E99C_pshpack2@h DB 01H
__D6556C4A_pshpack8@h DB 01H
__D98457C5_pshpack1@h DB 01H
__614C4572_apiset@h DB 01H
__8500295D_ktmtypes@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__156BD51A_minwindef@h DB 01H
__F9B9A8F7_windef@h DB 01H
__BD2C4590_apisetcconv@h DB 01H
__18251742_minwinbase@h DB 01H
__23611203_apiquery2@h DB 01H
__C914CD48_processenv@h DB 01H
__996311FD_fileapi@h DB 01H
__41AEF397_fileapifromapp@h DB 01H
__65579FF3_debugapi@h DB 01H
__476FCB5A_utilapiset@h DB 01H
__089D2E42_handleapi@h DB 01H
__B16F04F5_errhandlingapi@h DB 01H
__81CCB02F_fibersapi@h DB 01H
__A9B4C5F0_namedpipeapi@h DB 01H
__C209F2C8_profileapi@h DB 01H
__34C22DC8_heapapi@h DB 01H
__8A238485_ioapiset@h DB 01H
__4826BA69_synchapi@h DB 01H
__6A31599C_interlockedapi@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__7BB37CFA_sysinfoapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__6D078C0D_enclaveapi@h DB 01H
__3663CE50_threadpoollegacyapiset@h DB 01H
__E16717D9_threadpoolapiset@h DB 01H
__4A6035CC_jobapi@h DB 01H
__62EEB553_jobapi2@h DB 01H
__9F22E7EF_wow64apiset@h DB 01H
__E86B4A9A_libloaderapi@h DB 01H
__EB536E54_securitybaseapi@h DB 01H
__E915C287_namespaceapi@h DB 01H
__C66F44F2_systemtopologyapi@h DB 01H
__B6175B28_processtopologyapi@h DB 01H
__9E4AD838_securityappcontainer@h DB 01H
__F599FDAE_realtimeapiset@h DB 01H
__D4435474_winerror@h DB 01H
__F94F31E6_timezoneapi@h DB 01H
__B3ED30D4_winbase@h DB 01H
__E9F7D11F_wingdi@h DB 01H
__AC21C382_tvout@h DB 01H
__DB057BA3_winuser@h DB 01H
__A1BAD304_datetimeapi@h DB 01H
__30E2BD27_winnls@h DB 01H
__B7FF4B97_stringapiset@h DB 01H
__66C87297_wincontypes@h DB 01H
__1317218F_consoleapi@h DB 01H
__8D62D26D_consoleapi2@h DB 01H
__8CA0B85A_consoleapi3@h DB 01H
__CE39E65B_wincon@h DB 01H
__F6801ACC_verrsrc@h DB 01H
__1CB844D9_winver@h DB 01H
__D0CFA71C_reason@h DB 01H
__F3D58382_winreg@h DB 01H
__34C28572_wnnc@h DB 01H
__0617DE59_winnetwk@h DB 01H
__93AC9EF8_cderr@h DB 01H
__3AE29FFA_dde@h DB 01H
__48250249_ddeml@h DB 01H
__4605C6DD_dlgs@h DB 01H
__C826BBA2_lzexpand@h DB 01H
__B8DFB118_mmsyscom@h DB 01H
__EDC2A662_mciapi@h DB 01H
__87B17D5B_mmiscapi@h DB 01H
__0C4862FC_mmiscapi2@h DB 01H
__83F5D08C_playsoundapi@h DB 01H
__CA3F1D44_mmeapi@h DB 01H
__BD2270BE_timeapi@h DB 01H
__397CAA2F_joystickapi@h DB 01H
__05A21AEE_mmsystem@h DB 01H
__6E1DF0B6_nb30@h DB 01H
__75098885_rpcdcep@h DB 01H
__D8AC8DD5_rpcdce@h DB 01H
__2F1118EF_rpcnsi@h DB 01H
__0DE10DFC_rpcnterr@h DB 01H
__4497164E_rpcasync@h DB 01H
__06CA6763_rpc@h DB 01H
__C32EC2F2_shellapi@h DB 01H
__B289ECB8_winperf@h DB 01H
__07EA6B7C_inaddr@h DB 01H
__9ED0251E_winsock@h DB 01H
__FD938996_bcrypt@h DB 01H
__4E32BFB9_ncrypt@h DB 01H
__815AA9AD_dpapi@h DB 01H
__0B2E95FF_wincrypt@h DB 01H
__288F6C52_winefs@h DB 01H
__B3F2ECA2_rpcnsip@h DB 01H
__AFB43543_rpcsal@h DB 01H
__16A21838_rpcndr@h DB 01H
__5314805F_wtypesbase@h DB 01H
__6EEE3703_wtypes@h DB 01H
__A7113148_winioctl@h DB 01H
__C595A37C_winsmcrd@h DB 01H
__42C56FB7_winscard@h DB 01H
__C4703BCA_prsht@h DB 01H
__D4D77F19_winspool@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__AD973B64_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__B47185B4_unknwnbase@h DB 01H
__B64C33F8_objidlbase@h DB 01H
__EA871F04_cguid@h DB 01H
__C78732AB_combaseapi@h DB 01H
__744BF5DA_unknwn@h DB 01H
__66C491E7_objidl@h DB 01H
__A217658B_oaidl@h DB 01H
__8485F416_propidlbase@h DB 01H
__65805CE1_coml2api@h DB 01H
__C7AD586F_oleidl@h DB 01H
__CBE55221_servprov@h DB 01H
__5B1E268A_msxml@h DB 01H
__1B3D3678_urlmon@h DB 01H
__EC5BC72C_propidl@h DB 01H
__0DD0E8F8_objbase@h DB 01H
__6DA674A0_oleauto@h DB 01H
__F7931962_ole2@h DB 01H
__870E9EB1_commdlg@h DB 01H
__A118E6DC_stralign@h DB 01H
__8B10FA9F_winsvc@h DB 01H
__BEDBF511_mcx@h DB 01H
__D3BCC989_ime_cmodes@h DB 01H
__B1694579_imm@h DB 01H
__4D4D253D_windows@h DB 01H
__64F617E8_types@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__A9062FA3_lprintf@h DB 01H
__3ED4F62B_lprintf@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	lprintf
PUBLIC	__v_lprintf
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@		; `string'
PUBLIC	??_C@_0BB@GHIALFFI@0000000000000000@		; `string'
PUBLIC	??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_05MAGFAFAN@?$CInil?$CJ@			; `string'
PUBLIC	??_C@_09EDJNIEDM@?$CF?$CF?$CFd?4?$CFd?$CFc@	; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02MDDDDAID@0x@				; `string'
PUBLIC	??_C@_02FGLHBECB@0X@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	__real@0000000000000000
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcpy:PROC
EXTRN	__imp_strerror:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	get_ms:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lprintf DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$lprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__v_lprintf DD imagerel $LN84
	DD	imagerel $LN84+2291
	DD	imagerel $unwind$__v_lprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$skip_to DD imagerel skip_to
	DD	imagerel skip_to+100
	DD	imagerel $unwind$skip_to
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output DD imagerel output
	DD	imagerel output+656
	DD	imagerel $unwind$output
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_pad DD imagerel write_pad
	DD	imagerel write_pad+188
	DD	imagerel $unwind$write_pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$int64_str DD imagerel int64_str
	DD	imagerel int64_str+426
	DD	imagerel $unwind$int64_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_string DD imagerel output_string
	DD	imagerel output_string+555
	DD	imagerel $unwind$output_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_integer DD imagerel output_integer
	DD	imagerel output_integer+1034
	DD	imagerel $unwind$output_integer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_double DD imagerel output_double
	DD	imagerel output_double+744
	DD	imagerel $unwind$output_double
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_memory_block DD imagerel output_memory_block
	DD	imagerel output_memory_block+840
	DD	imagerel $unwind$output_memory_block
pdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLHBECB@0X@
CONST	SEGMENT
??_C@_02FGLHBECB@0X@ DB '0X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x@
CONST	SEGMENT
??_C@_02MDDDDAID@0x@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@ DB '(%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDJNIEDM@?$CF?$CF?$CFd?4?$CFd?$CFc@
CONST	SEGMENT
??_C@_09EDJNIEDM@?$CF?$CF?$CFd?4?$CFd?$CFc@ DB '%%%d.%d%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAGFAFAN@?$CInil?$CJ@
CONST	SEGMENT
??_C@_05MAGFAFAN@?$CInil?$CJ@ DB '(nil)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB '                '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHIALFFI@0000000000000000@
CONST	SEGMENT
??_C@_0BB@GHIALFFI@0000000000000000@ DB '0000000000000000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
CONST	SEGMENT
??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@ DB '%03d.%03d ', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?sol@?1??output@@9@9 DD 01H				; `output'::`2'::sol
	ORG $+4
?char_set@?1??output_memory_block@@9@9 DQ FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@ ; `output_memory_block'::`2'::char_set
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	032fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_memory_block DD 045054b19H
	DD	011c4321H
	DD	07015004dH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0258H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_memory_block$rtcName$0 DB 073H
	DB	074H
	DB	072H
	DB	00H
	ORG $+12
output_memory_block$rtcVarDesc DD 050H
	DD	0100H
	DQ	FLAT:output_memory_block$rtcName$0
	ORG $+48
output_memory_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output_memory_block$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03dH
	DW	02cfH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_double DD 045054419H
	DD	011d4322H
	DD	070160061H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	02f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_double$rtcName$0 DB 066H
	DB	06dH
	DB	074H
	DB	00H
output_double$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+8
output_double$rtcVarDesc DD 0b0H
	DD	0100H
	DQ	FLAT:output_double$rtcName$1
	DD	050H
	DD	040H
	DQ	FLAT:output_double$rtcName$0
	ORG $+96
output_double$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:output_double$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	03f1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_integer DD 045054b19H
	DD	011c4321H
	DD	07015004bH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_integer$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+12
output_integer$rtcVarDesc DD 050H
	DD	080H
	DQ	FLAT:output_integer$rtcName$0
	ORG $+48
output_integer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output_integer$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_string DD 025052101H
	DD	011c2321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$int64_str DD 025052101H
	DD	011c2321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_pad DD 025051601H
	DD	01112316H
	DD	0700a0025H
	DD	05009H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	0277H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output DD 025054119H
	DD	01122317H
	DD	0700b003bH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output$rtcName$0 DB 074H
	DB	069H
	DB	06dH
	DB	065H
	DB	073H
	DB	074H
	DB	061H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+6
output$rtcVarDesc DD 068H
	DD	020H
	DQ	FLAT:output$rtcName$0
	ORG $+48
output$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skip_to DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	07b9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__v_lprintf DD 055054219H
	DD	01135318H
	DD	0700c0061H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	02f0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
__v_lprintf$rtcName$0 DB 073H
	DB	00H
	ORG $+2
__v_lprintf$rtcName$1 DB 063H
	DB	068H
	DB	00H
	ORG $+9
__v_lprintf$rtcVarDesc DD 0114H
	DD	01H
	DQ	FLAT:__v_lprintf$rtcName$1
	DD	098H
	DD	08H
	DQ	FLAT:__v_lprintf$rtcName$0
	ORG $+96
__v_lprintf$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:__v_lprintf$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	095H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
lprintf$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+8
lprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:lprintf$rtcName$0
	ORG $+48
lprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:lprintf$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	09fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT output_memory_block
_TEXT	SEGMENT
str$ = 16
s$ = 296
len$ = 324
__$ArrayPad$ = 536
ptr$ = 576
n$ = 584
width$ = 592
precision$ = 600
flag$ = 608
pad$ = 616
output_memory_block PROC				; COMDAT

; 324  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 616				; 00000268H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+648]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 325  :     static const char *char_set = "0123456789abcdef";
; 326  :     char str[256], *s;
; 327  :     int len = 0;

	mov	DWORD PTR len$[rbp], 0

; 328  :     
; 329  :     if (ptr == NULL) 

	cmp	QWORD PTR ptr$[rbp], 0
	jne	SHORT $LN4@output_mem

; 330  :         return output_string("(null)", 6, 0, width, precision, flag, pad, ' ');

	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, 6
	lea	rcx, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	call	output_string
	jmp	$LN1@output_mem
$LN4@output_mem:

; 331  : 
; 332  :     s = str; 

	lea	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR s$[rbp], rax

; 333  :     if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@output_mem

; 334  :         s += sprintf(s, "(%d) ", n);

	mov	r8d, DWORD PTR n$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
	mov	rcx, QWORD PTR s$[rbp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR s$[rbp], rax
$LN5@output_mem:

; 335  : 
; 336  :     if (n > (sizeof(str) - 32) / 3) 

	movsxd	rax, DWORD PTR n$[rbp]
	cmp	rax, 74					; 0000004aH
	jbe	SHORT $LN6@output_mem

; 337  :         width = precision = 0;

	mov	DWORD PTR precision$[rbp], 0
	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR width$[rbp], eax
$LN6@output_mem:
$LN2@output_mem:

; 338  :         
; 339  :     while (n > 0) {

	cmp	DWORD PTR n$[rbp], 0
	jle	$LN3@output_mem

; 340  :         if (pad != '0' && *ptr < 0x10) 

	cmp	DWORD PTR pad$[rbp], 48			; 00000030H
	je	SHORT $LN7@output_mem
	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 16
	jge	SHORT $LN7@output_mem

; 341  :             *s++ = char_set[*ptr];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
	jmp	SHORT $LN8@output_mem
$LN7@output_mem:

; 342  :         else {
; 343  :             *s++ = char_set[*ptr / 16];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax

; 344  :             *s++ = char_set[*ptr % 16];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
$LN8@output_mem:

; 345  :         }
; 346  : 
; 347  :         n--;

	mov	eax, DWORD PTR n$[rbp]
	dec	eax
	mov	DWORD PTR n$[rbp], eax

; 348  :         if (n > 0)

	cmp	DWORD PTR n$[rbp], 0
	jle	SHORT $LN9@output_mem

; 349  :             *s++ = ' ';

	mov	rax, QWORD PTR s$[rbp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
$LN9@output_mem:

; 350  : 
; 351  :         ptr++;

	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax

; 352  :         if (s - str > sizeof(str) - 4) {

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 252				; 000000fcH
	jbe	SHORT $LN10@output_mem

; 353  :             len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	ecx, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], cl
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, eax
	lea	rcx, QWORD PTR str$[rbp]
	call	output_string
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 354  :             s = str;

	lea	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR s$[rbp], rax
$LN10@output_mem:

; 355  :         }
; 356  :     }

	jmp	$LN2@output_mem
$LN3@output_mem:

; 357  : 
; 358  :     if (s != str) 

	lea	rax, QWORD PTR str$[rbp]
	cmp	QWORD PTR s$[rbp], rax
	je	SHORT $LN11@output_mem

; 359  :         len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	ecx, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], cl
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, eax
	lea	rcx, QWORD PTR str$[rbp]
	call	output_string
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN11@output_mem:

; 360  : 
; 361  :     return len;

	mov	eax, DWORD PTR len$[rbp]
$LN1@output_mem:

; 362  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_memory_block$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+552]
	pop	rdi
	pop	rbp
	ret	0
output_memory_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT output_double
_TEXT	SEGMENT
fmt$ = 16
buf$ = 112
s$ = 392
p$ = 424
prefix_len$ = 452
sz$ = 484
tv95 = 692
__$ArrayPad$ = 696
d$ = 736
type$ = 744
width$ = 752
precision$ = 760
flag$ = 768
pad$ = 776
output_double PROC					; COMDAT

; 272  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	movsd	QWORD PTR [rsp+8], xmm0
	push	rbp
	push	rdi
	sub	rsp, 776				; 00000308H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 273  :     char fmt[64], buf[256], *s, *p;
; 274  :     int prefix_len = 0, sz;

	mov	DWORD PTR prefix_len$[rbp], 0

; 275  : 
; 276  :     if (width == 0) 

	cmp	DWORD PTR width$[rbp], 0
	jne	SHORT $LN8@output_dou

; 277  :         width = 1;

	mov	DWORD PTR width$[rbp], 1
$LN8@output_dou:

; 278  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN9@output_dou

; 279  :         precision = 6;

	mov	DWORD PTR precision$[rbp], 6
$LN9@output_dou:

; 280  :     if (d < 0.0) 

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR d$[rbp]
	jbe	SHORT $LN10@output_dou

; 281  :         prefix_len = 1;

	mov	DWORD PTR prefix_len$[rbp], 1
$LN10@output_dou:

; 282  : 
; 283  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 284  :     
; 285  :     sprintf(fmt, "%%%d.%d%c", width, precision, type);

	movsx	eax, BYTE PTR type$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR precision$[rbp]
	mov	r8d, DWORD PTR width$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_09EDJNIEDM@?$CF?$CF?$CFd?4?$CFd?$CFc@
	lea	rcx, QWORD PTR fmt$[rbp]
	call	sprintf

; 286  :     sprintf(s, fmt, d);

	movsd	xmm2, QWORD PTR d$[rbp]
	movq	r8, xmm2
	lea	rdx, QWORD PTR fmt$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	sprintf

; 287  :     
; 288  :     for (p = s; *p == ' '; p++);

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR p$[rbp], rax
	jmp	SHORT $LN4@output_dou
$LN2@output_dou:
	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN4@output_dou:
	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@output_dou
	jmp	SHORT $LN2@output_dou
$LN3@output_dou:
$LN5@output_dou:

; 289  : 
; 290  :     for (;;) {
; 291  :         *s = *p;

	mov	rax, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 292  :         if (*p == '\0')

	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN11@output_dou

; 293  :             break;

	jmp	SHORT $LN6@output_dou
$LN11@output_dou:

; 294  :         s++;

	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax

; 295  :         p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax

; 296  :     } 

	jmp	SHORT $LN5@output_dou
$LN6@output_dou:

; 297  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 298  :     sz = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	DWORD PTR sz$[rbp], eax

; 299  : 
; 300  :     if ((flag & (F_PLUS | F_SPACE)) && d >= 0) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN12@output_dou
	movsd	xmm0, QWORD PTR d$[rbp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN12@output_dou

; 301  :         prefix_len = 1;

	mov	DWORD PTR prefix_len$[rbp], 1

; 302  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN16@output_dou
	mov	DWORD PTR tv95[rbp], 43			; 0000002bH
	jmp	SHORT $LN17@output_dou
$LN16@output_dou:
	mov	DWORD PTR tv95[rbp], 32			; 00000020H
$LN17@output_dou:
	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	movzx	ecx, BYTE PTR tv95[rbp]
	mov	BYTE PTR [rax], cl

; 303  :         sz++;

	mov	eax, DWORD PTR sz$[rbp]
	inc	eax
	mov	DWORD PTR sz$[rbp], eax
$LN12@output_dou:

; 304  :     }
; 305  :     
; 306  :     if ((flag & F_HASH) && type == 'f' && strchr(s, '.') == NULL) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN13@output_dou
	movsx	eax, BYTE PTR type$[rbp]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN13@output_dou
	mov	edx, 46					; 0000002eH
	mov	rcx, QWORD PTR s$[rbp]
	call	strchr
	test	rax, rax
	jne	SHORT $LN13@output_dou

; 307  :         s[sz++] = '.';

	movsxd	rax, DWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH
	mov	eax, DWORD PTR sz$[rbp]
	inc	eax
	mov	DWORD PTR sz$[rbp], eax
$LN13@output_dou:

; 308  :     
; 309  :     if (width < sz) 

	mov	eax, DWORD PTR sz$[rbp]
	cmp	DWORD PTR width$[rbp], eax
	jge	SHORT $LN14@output_dou

; 310  :         width = sz;

	mov	eax, DWORD PTR sz$[rbp]
	mov	DWORD PTR width$[rbp], eax
$LN14@output_dou:

; 311  :     flag &= ~F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, -65				; ffffffffffffffbfH
	mov	DWORD PTR flag$[rbp], eax

; 312  : 
; 313  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	mov	BYTE PTR [rsp+56], 48			; 00000030H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR width$[rbp]
	mov	r8d, DWORD PTR prefix_len$[rbp]
	mov	edx, DWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string

; 314  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_double$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+712]
	pop	rdi
	pop	rbp
	ret	0
output_double ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT output_integer
_TEXT	SEGMENT
buf$ = 16
s$ = 168
sz$ = 196
prefix_len$ = 228
n$ = 260
is_negative$ = 292
tv165 = 500
tv142 = 504
__$ArrayPad$ = 512
num$ = 560
opt_long$ = 568
type$ = 576
width$ = 584
precision$ = 592
flag$ = 600
base$ = 608
prefix$ = 616
pad$ = 624
output_integer PROC					; COMDAT

; 204  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 600				; 00000258H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+632]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 205  :     char buf[128], *s;
; 206  :     int sz, prefix_len, n;
; 207  :     bool is_negative;
; 208  : 
; 209  :     if (precision > width) 

	mov	eax, DWORD PTR width$[rbp]
	cmp	DWORD PTR precision$[rbp], eax
	jle	SHORT $LN2@output_int

; 210  :         width = precision;

	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR width$[rbp], eax
$LN2@output_int:

; 211  :     
; 212  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 213  :     if (type == 'p') {

	movsx	eax, BYTE PTR type$[rbp]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN3@output_int

; 214  :         if (num == 0) {

	cmp	QWORD PTR num$[rbp], 0
	jne	SHORT $LN4@output_int

; 215  :             s = "(nil)";

	lea	rax, OFFSET FLAT:??_C@_05MAGFAFAN@?$CInil?$CJ@
	mov	QWORD PTR s$[rbp], rax

; 216  :             return output_string(s, strlen(s), 0, width, precision, flag, ' ', ' ');

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	mov	BYTE PTR [rsp+48], 32			; 00000020H
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	ecx, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, eax
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
	jmp	$LN1@output_int
$LN4@output_int:
$LN3@output_int:

; 217  :         } 
; 218  :     } 
; 219  : 
; 220  :     strcpy(s, prefix);

	mov	rdx, QWORD PTR prefix$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	strcpy

; 221  :     sz = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	DWORD PTR sz$[rbp], eax

; 222  :     prefix_len = sz;

	mov	eax, DWORD PTR sz$[rbp]
	mov	DWORD PTR prefix_len$[rbp], eax

; 223  : 
; 224  :     is_negative = false;

	mov	DWORD PTR is_negative$[rbp], 0

; 225  :     if (flag & F_SIGN) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@output_int

; 226  :         if ((signed __int64)num < 0) {

	cmp	QWORD PTR num$[rbp], 0
	jge	SHORT $LN6@output_int

; 227  :             num = -(signed __int64)num;

	mov	rax, QWORD PTR num$[rbp]
	neg	rax
	mov	QWORD PTR num$[rbp], rax

; 228  :             is_negative = true;

	mov	DWORD PTR is_negative$[rbp], 1
$LN6@output_int:
$LN5@output_int:

; 229  :         }
; 230  :     } 
; 231  :     
; 232  :     if (opt_long == 1)

	cmp	DWORD PTR opt_long$[rbp], 1
	jne	SHORT $LN7@output_int

; 233  :         num &= (unsigned long)-1;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR num$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN8@output_int
$LN7@output_int:

; 234  :     else if (opt_long == 0)

	cmp	DWORD PTR opt_long$[rbp], 0
	jne	SHORT $LN9@output_int

; 235  :         num &= (unsigned int)-1;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR num$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN10@output_int
$LN9@output_int:

; 236  :     else if (opt_long == -1) 

	cmp	DWORD PTR opt_long$[rbp], -1
	jne	SHORT $LN11@output_int

; 237  :         num &= 0xffff;

	mov	rax, QWORD PTR num$[rbp]
	and	rax, 65535				; 0000ffffH
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN12@output_int
$LN11@output_int:

; 238  :     else if (opt_long == -2) 

	cmp	DWORD PTR opt_long$[rbp], -2
	jne	SHORT $LN13@output_int

; 239  :         num &= 0xff;

	mov	rax, QWORD PTR num$[rbp]
	and	rax, 255				; 000000ffH
	mov	QWORD PTR num$[rbp], rax
$LN13@output_int:
$LN12@output_int:
$LN10@output_int:
$LN8@output_int:

; 240  : 
; 241  :     n = int64_str(s + sz, sizeof(buf) - sz - 1, num, base, flag & F_UPCASE);

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 2
	movsxd	rcx, DWORD PTR sz$[rbp]
	mov	edx, 128				; 00000080H
	sub	rdx, rcx
	mov	rcx, rdx
	dec	rcx
	movsxd	rdx, DWORD PTR sz$[rbp]
	mov	r8, QWORD PTR s$[rbp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv142[rbp], rdx
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR base$[rbp]
	mov	r8, QWORD PTR num$[rbp]
	mov	edx, ecx
	mov	rax, QWORD PTR tv142[rbp]
	mov	rcx, rax
	call	int64_str
	mov	DWORD PTR n$[rbp], eax

; 242  : 
; 243  :     /* When 0 is printed with an explicit precision 0, the output is empty. */
; 244  :     if ((flag & F_DOT) && n == 1 && s[sz] == '0') {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN14@output_int
	cmp	DWORD PTR n$[rbp], 1
	jne	SHORT $LN14@output_int
	movsxd	rax, DWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN14@output_int

; 245  :         if (precision == 0 || prefix_len > 0) 

	cmp	DWORD PTR precision$[rbp], 0
	je	SHORT $LN17@output_int
	cmp	DWORD PTR prefix_len$[rbp], 0
	jle	SHORT $LN16@output_int
$LN17@output_int:

; 246  :             sz = 0;

	mov	DWORD PTR sz$[rbp], 0
$LN16@output_int:

; 247  :         prefix_len = 0;

	mov	DWORD PTR prefix_len$[rbp], 0

; 248  :     } else 

	jmp	SHORT $LN15@output_int
$LN14@output_int:

; 249  :         sz += n;

	mov	eax, DWORD PTR n$[rbp]
	mov	ecx, DWORD PTR sz$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR sz$[rbp], eax
$LN15@output_int:

; 250  :     
; 251  :     if (is_negative) {

	cmp	DWORD PTR is_negative$[rbp], 0
	je	SHORT $LN18@output_int

; 252  :         prefix_len = 1;

	mov	DWORD PTR prefix_len$[rbp], 1

; 253  :         *(--s) = '-';

	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 254  :         sz++;

	mov	eax, DWORD PTR sz$[rbp]
	inc	eax
	mov	DWORD PTR sz$[rbp], eax
	jmp	SHORT $LN19@output_int
$LN18@output_int:

; 255  :     } else if ((flag & F_SIGN) && (flag & (F_PLUS | F_SPACE))) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN20@output_int
	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN20@output_int

; 256  :         prefix_len = 1;

	mov	DWORD PTR prefix_len$[rbp], 1

; 257  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN24@output_int
	mov	DWORD PTR tv165[rbp], 43		; 0000002bH
	jmp	SHORT $LN25@output_int
$LN24@output_int:
	mov	DWORD PTR tv165[rbp], 32		; 00000020H
$LN25@output_int:
	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	movzx	ecx, BYTE PTR tv165[rbp]
	mov	BYTE PTR [rax], cl

; 258  :         sz++;

	mov	eax, DWORD PTR sz$[rbp]
	inc	eax
	mov	DWORD PTR sz$[rbp], eax
$LN20@output_int:
$LN19@output_int:

; 259  :     } 
; 260  : 
; 261  :     if (precision > 0)

	cmp	DWORD PTR precision$[rbp], 0
	jle	SHORT $LN21@output_int

; 262  :         pad = ' ';

	mov	BYTE PTR pad$[rbp], 32			; 00000020H
$LN21@output_int:

; 263  : 
; 264  :     if (sz - prefix_len > precision)

	mov	eax, DWORD PTR prefix_len$[rbp]
	mov	ecx, DWORD PTR sz$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR precision$[rbp]
	jle	SHORT $LN22@output_int

; 265  :         precision = sz - prefix_len;

	mov	eax, DWORD PTR prefix_len$[rbp]
	mov	ecx, DWORD PTR sz$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR precision$[rbp], eax
$LN22@output_int:

; 266  : 
; 267  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	mov	BYTE PTR [rsp+56], 48			; 00000030H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR width$[rbp]
	mov	r8d, DWORD PTR prefix_len$[rbp]
	mov	edx, DWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
$LN1@output_int:

; 268  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_integer$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+536]
	pop	rdi
	pop	rbp
	ret	0
output_integer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT output_string
_TEXT	SEGMENT
prefix$ = 8
len$ = 36
str$ = 288
size$ = 296
prefix_len$ = 304
width$ = 312
precision$ = 320
flag$ = 328
pad$ = 336
precision_pad$ = 344
output_string PROC					; COMDAT

; 131  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 132  :     const char *prefix;
; 133  :     int len = 0;

	mov	DWORD PTR len$[rbp], 0

; 134  : 
; 135  :     if (width == 0 && precision == 0) {

	cmp	DWORD PTR width$[rbp], 0
	jne	SHORT $LN2@output_str
	cmp	DWORD PTR precision$[rbp], 0
	jne	SHORT $LN2@output_str

; 136  :         output(str, size); 

	mov	edx, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	call	output

; 137  :         return size;

	mov	eax, DWORD PTR size$[rbp]
	jmp	$LN1@output_str
$LN2@output_str:

; 138  :     }
; 139  :     
; 140  :     prefix = str;

	mov	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR prefix$[rbp], rax

; 141  :     
; 142  :     if (prefix_len) {

	cmp	DWORD PTR prefix_len$[rbp], 0
	je	SHORT $LN3@output_str

; 143  :         str += prefix_len;

	movsxd	rax, DWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR str$[rbp], rax

; 144  :         size -= prefix_len;

	mov	eax, DWORD PTR prefix_len$[rbp]
	mov	ecx, DWORD PTR size$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR size$[rbp], eax

; 145  :         width -= prefix_len;

	mov	eax, DWORD PTR prefix_len$[rbp]
	mov	ecx, DWORD PTR width$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR width$[rbp], eax
$LN3@output_str:

; 146  :     }
; 147  :     
; 148  :     /* These are the cases for 1234 or "1234" respectively:
; 149  :         %.6u -> "001234"
; 150  :         %6u  -> "  1234"
; 151  :         %06u -> "001234"
; 152  :         %-6u -> "1234  "
; 153  :         %.6s -> "1234"
; 154  :         %6s  -> "  1234"
; 155  :         %06s -> "  1234"
; 156  :         %-6s -> "1234  "
; 157  :         %6.5u -> " 01234"
; 158  :         %6.5s -> "  1234"
; 159  :         In this code, for %6.5s, 6 is width, 5 is precision.
; 160  :         flag_dot means there was a '.' and precision is set.
; 161  :         flag_left means there was a '-'.
; 162  :         sz is 4 (strlen("1234")).
; 163  :         pad will be '0' for %06u, ' ' otherwise.
; 164  :         precision_pad is '0' for %u, ' ' for %s.
; 165  :     */
; 166  :     
; 167  :     if ((flag & F_DOT) && width == 0) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN4@output_str
	cmp	DWORD PTR width$[rbp], 0
	jne	SHORT $LN4@output_str

; 168  :         width = precision;

	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR width$[rbp], eax
$LN4@output_str:

; 169  :     
; 170  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN5@output_str

; 171  :         precision = size;

	mov	eax, DWORD PTR size$[rbp]
	mov	DWORD PTR precision$[rbp], eax
$LN5@output_str:

; 172  : 
; 173  :     /* do left-side padding with spaces */
; 174  :     if (!(flag & F_LEFT) && pad == ' ') 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@output_str
	movsx	eax, BYTE PTR pad$[rbp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@output_str

; 175  :         len += write_pad(width - precision, ' ');

	mov	eax, DWORD PTR precision$[rbp]
	mov	ecx, DWORD PTR width$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	edx, 32					; 00000020H
	mov	ecx, eax
	call	write_pad
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN6@output_str:

; 176  :     
; 177  :     if (prefix_len) {

	cmp	DWORD PTR prefix_len$[rbp], 0
	je	SHORT $LN7@output_str

; 178  :         output(prefix, prefix_len);

	mov	edx, DWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR prefix$[rbp]
	call	output

; 179  :         len += prefix_len;

	mov	eax, DWORD PTR prefix_len$[rbp]
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN7@output_str:

; 180  :     }
; 181  : 
; 182  :     /* do left-side padding with '0' */
; 183  :     if (!(flag & F_LEFT) && pad == '0') 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN8@output_str
	movsx	eax, BYTE PTR pad$[rbp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN8@output_str

; 184  :         len += write_pad(width - precision, '0');

	mov	eax, DWORD PTR precision$[rbp]
	mov	ecx, DWORD PTR width$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	edx, 48					; 00000030H
	mov	ecx, eax
	call	write_pad
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN8@output_str:

; 185  :     
; 186  :     /* do precision padding */
; 187  :     len += write_pad(precision - size, precision_pad);

	movsx	eax, BYTE PTR precision_pad$[rbp]
	mov	ecx, DWORD PTR size$[rbp]
	mov	edx, DWORD PTR precision$[rbp]
	sub	edx, ecx
	mov	ecx, edx
	mov	edx, eax
	call	write_pad
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 188  :     
; 189  :     /* write actual string */
; 190  :     output(str, size); 

	mov	edx, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	call	output

; 191  :     len += size;

	mov	eax, DWORD PTR size$[rbp]
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 192  : 
; 193  :     /* do right-side padding */
; 194  :     if (flag & F_LEFT) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN9@output_str

; 195  :         len += write_pad(width - precision, pad);

	movsx	eax, BYTE PTR pad$[rbp]
	mov	ecx, DWORD PTR precision$[rbp]
	mov	edx, DWORD PTR width$[rbp]
	sub	edx, ecx
	mov	ecx, edx
	mov	edx, eax
	call	write_pad
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN9@output_str:

; 196  : 
; 197  :     return len;

	mov	eax, DWORD PTR len$[rbp]
$LN1@output_str:

; 198  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
output_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT int64_str
_TEXT	SEGMENT
p$ = 8
j$ = 36
tv85 = 244
tv91 = 248
tv77 = 248
s$ = 288
size$ = 296
i$ = 304
base$ = 312
upcase$ = 320
int64_str PROC						; COMDAT

; 88   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 89   :     char *p;
; 90   :     unsigned int j = 0;

	mov	DWORD PTR j$[rbp], 0

; 91   :     
; 92   :     s[--size] = 0; 

	mov	eax, DWORD PTR size$[rbp]
	dec	eax
	mov	DWORD PTR size$[rbp], eax
	movsxd	rax, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 93   :     
; 94   :     p = s + size;

	movsxd	rax, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rbp], rax

; 95   :     
; 96   :     if (base == 0 || base > 36) 

	cmp	DWORD PTR base$[rbp], 0
	je	SHORT $LN5@int64_str
	cmp	DWORD PTR base$[rbp], 36		; 00000024H
	jle	SHORT $LN4@int64_str
$LN5@int64_str:

; 97   :         base = 10;

	mov	DWORD PTR base$[rbp], 10
$LN4@int64_str:

; 98   :     
; 99   :     j = 0;

	mov	DWORD PTR j$[rbp], 0

; 100  :     if (i == 0) {

	cmp	QWORD PTR i$[rbp], 0
	jne	SHORT $LN6@int64_str

; 101  :         *(--p) = '0';

	mov	rax, QWORD PTR p$[rbp]
	dec	rax
	mov	QWORD PTR p$[rbp], rax
	mov	rax, QWORD PTR p$[rbp]
	mov	BYTE PTR [rax], 48			; 00000030H

; 102  :         j = 1;

	mov	DWORD PTR j$[rbp], 1
$LN6@int64_str:
$LN2@int64_str:

; 103  :     }
; 104  :     
; 105  :     while (p > s && i != 0) {

	mov	rax, QWORD PTR s$[rbp]
	cmp	QWORD PTR p$[rbp], rax
	jbe	$LN3@int64_str
	cmp	QWORD PTR i$[rbp], 0
	je	$LN3@int64_str

; 106  :         p--;

	mov	rax, QWORD PTR p$[rbp]
	dec	rax
	mov	QWORD PTR p$[rbp], rax

; 107  :         *p = (char)(i % base + '0');

	movsxd	rax, DWORD PTR base$[rbp]
	mov	QWORD PTR tv77[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rbp]
	mov	rcx, QWORD PTR tv77[rbp]
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR p$[rbp]
	mov	BYTE PTR [rcx], al

; 108  :         if (*p > '9') 

	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN7@int64_str

; 109  :             *p += (upcase ? 'A' : 'a') - '9' - 1;

	movsx	eax, BYTE PTR upcase$[rbp]
	test	eax, eax
	je	SHORT $LN9@int64_str
	mov	DWORD PTR tv85[rbp], 65			; 00000041H
	jmp	SHORT $LN10@int64_str
$LN9@int64_str:
	mov	DWORD PTR tv85[rbp], 97			; 00000061H
$LN10@int64_str:
	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR tv85[rbp]
	lea	eax, DWORD PTR [rax+rcx-58]
	mov	rcx, QWORD PTR p$[rbp]
	mov	BYTE PTR [rcx], al
$LN7@int64_str:

; 110  :         i /= base;

	movsxd	rax, DWORD PTR base$[rbp]
	mov	QWORD PTR tv91[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rbp]
	mov	rcx, QWORD PTR tv91[rbp]
	div	rcx
	mov	QWORD PTR i$[rbp], rax

; 111  :         j++;

	mov	eax, DWORD PTR j$[rbp]
	inc	eax
	mov	DWORD PTR j$[rbp], eax

; 112  :     }

	jmp	$LN2@int64_str
$LN3@int64_str:

; 113  : 
; 114  :     memmove(s, p, j + 1);

	mov	eax, DWORD PTR j$[rbp]
	inc	eax
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	memmove

; 115  : 
; 116  :     return j;

	mov	eax, DWORD PTR j$[rbp]

; 117  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
int64_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT write_pad
_TEXT	SEGMENT
pad$ = 8
n$ = 36
len$ = 288
pad_ch$ = 296
write_pad PROC						; COMDAT

; 66   : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 67   :     const char *pad;
; 68   :     int n;
; 69   : 
; 70   :     if ((int)len <= 0) 

	cmp	DWORD PTR len$[rbp], 0
	jg	SHORT $LN5@write_pad

; 71   :         return 0;

	xor	eax, eax
	jmp	$LN1@write_pad
$LN5@write_pad:

; 72   : 
; 73   :     if (pad_ch == '0')

	cmp	DWORD PTR pad_ch$[rbp], 48		; 00000030H
	jne	SHORT $LN6@write_pad

; 74   :         pad = "0000000000000000";

	lea	rax, OFFSET FLAT:??_C@_0BB@GHIALFFI@0000000000000000@
	mov	QWORD PTR pad$[rbp], rax
	jmp	SHORT $LN7@write_pad
$LN6@write_pad:

; 75   :     else
; 76   :         pad = "                ";

	lea	rax, OFFSET FLAT:??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
	mov	QWORD PTR pad$[rbp], rax
$LN7@write_pad:

; 77   : 
; 78   :     for (n = 0; len > 15; len -= 16, n += 16) 

	mov	DWORD PTR n$[rbp], 0
	jmp	SHORT $LN4@write_pad
$LN2@write_pad:
	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 16
	mov	DWORD PTR len$[rbp], eax
	mov	eax, DWORD PTR n$[rbp]
	add	eax, 16
	mov	DWORD PTR n$[rbp], eax
$LN4@write_pad:
	cmp	DWORD PTR len$[rbp], 15
	jbe	SHORT $LN3@write_pad

; 79   :         output(pad, 16);

	mov	edx, 16
	mov	rcx, QWORD PTR pad$[rbp]
	call	output
	jmp	SHORT $LN2@write_pad
$LN3@write_pad:

; 80   : 
; 81   :     if (len > 0) 

	cmp	DWORD PTR len$[rbp], 0
	jbe	SHORT $LN8@write_pad

; 82   :         n += output(pad, len); 

	mov	edx, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR pad$[rbp]
	call	output
	mov	ecx, DWORD PTR n$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR n$[rbp], eax
$LN8@write_pad:

; 83   : 
; 84   :     return n;

	mov	eax, DWORD PTR n$[rbp]
$LN1@write_pad:

; 85   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
write_pad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT output
_TEXT	SEGMENT
ms$ = 4
n$ = 36
timestamp$ = 72
head$ = 136
tail$ = 168
end$ = 200
tv147 = 404
tv77 = 404
tv71 = 404
tv72 = 408
__$ArrayPad$ = 416
str$ = 464
len$ = 472
output	PROC						; COMDAT

; 46   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 47   : 	static bool sol = true; /* start of line */
; 48   : 	unsigned int ms, n;
; 49   : 	char timestamp[32];
; 50   : 	const char *head, *tail, *end = str + len;

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rbp], rax

; 51   : 
; 52   : 	for (head = tail = str; tail < end; head = tail) {

	mov	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR tail$[rbp], rax
	mov	rax, QWORD PTR tail$[rbp]
	mov	QWORD PTR head$[rbp], rax
	jmp	SHORT $LN4@output
$LN2@output:
	mov	rax, QWORD PTR tail$[rbp]
	mov	QWORD PTR head$[rbp], rax
$LN4@output:
	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR tail$[rbp], rax
	jae	$LN3@output
$LN5@output:

; 53   : 		while (tail < end && *tail++ != '\n');

	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR tail$[rbp], rax
	jae	SHORT $LN6@output
	mov	rax, QWORD PTR tail$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv71[rbp], eax
	mov	rax, QWORD PTR tail$[rbp]
	inc	rax
	mov	QWORD PTR tail$[rbp], rax
	cmp	DWORD PTR tv71[rbp], 10
	je	SHORT $LN17@output
	mov	DWORD PTR tv72[rbp], 1
	jmp	SHORT $LN18@output
$LN17@output:
	mov	DWORD PTR tv72[rbp], 0
$LN18@output:
	cmp	DWORD PTR tv72[rbp], 0
	je	SHORT $LN6@output
	jmp	SHORT $LN5@output
$LN6@output:

; 54   : 		if (sol) {

	cmp	DWORD PTR ?sol@?1??output@@9@9, 0
	je	$LN13@output

; 55   : 			ms = get_ms();

	call	get_ms
	mov	DWORD PTR ms$[rbp], eax

; 56   : 			n = sprintf(timestamp, "%03d.%03d ", ms / 1000, ms % 1000);

	xor	edx, edx
	mov	eax, DWORD PTR ms$[rbp]
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	eax, edx
	mov	DWORD PTR tv77[rbp], eax
	xor	edx, edx
	mov	eax, DWORD PTR ms$[rbp]
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, DWORD PTR tv77[rbp]
	mov	r9d, ecx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	sprintf
	mov	DWORD PTR n$[rbp], eax
$LN9@output:

; 57   : 			tee_output(timestamp, n);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	ecx, DWORD PTR n$[rbp]
	mov	r9, rax
	mov	r8d, ecx
	mov	edx, 1
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	QWORD PTR __imp_fwrite
	cmp	QWORD PTR log_file, 0
	je	SHORT $LN14@output
	mov	eax, DWORD PTR n$[rbp]
	mov	r9, QWORD PTR log_file
	mov	r8d, eax
	mov	edx, 1
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	QWORD PTR __imp_fwrite
$LN14@output:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@output
$LN13@output:
$LN12@output:

; 58   : 		}
; 59   : 		tee_output(head, tail - head);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR head$[rbp]
	mov	rdx, QWORD PTR tail$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, rcx
	mov	edx, 1
	mov	rcx, QWORD PTR head$[rbp]
	call	QWORD PTR __imp_fwrite
	cmp	QWORD PTR log_file, 0
	je	SHORT $LN15@output
	mov	rax, QWORD PTR head$[rbp]
	mov	rcx, QWORD PTR tail$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR log_file
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR head$[rbp]
	call	QWORD PTR __imp_fwrite
$LN15@output:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@output

; 60   : 		sol = tail[-1] == '\n';

	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR tail$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	SHORT $LN19@output
	mov	DWORD PTR tv147[rbp], 1
	jmp	SHORT $LN20@output
$LN19@output:
	mov	DWORD PTR tv147[rbp], 0
$LN20@output:
	mov	eax, DWORD PTR tv147[rbp]
	mov	DWORD PTR ?sol@?1??output@@9@9, eax

; 61   : 	}

	jmp	$LN2@output
$LN3@output:

; 62   : 	return len;

	mov	eax, DWORD PTR len$[rbp]

; 63   : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:output$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+440]
	pop	rdi
	pop	rbp
	ret	0
output	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT skip_to
_TEXT	SEGMENT
i$ = 4
format$ = 256
skip_to	PROC						; COMDAT

; 33   : static unsigned long skip_to(const char *format) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 34   :     unsigned long i;
; 35   :     for (i = 0; format[i] && format[i] != '%'; ++i);

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@skip_to
$LN2@skip_to:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@skip_to:
	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@skip_to
	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN3@skip_to
	jmp	SHORT $LN2@skip_to
$LN3@skip_to:

; 36   :     return i;

	mov	eax, DWORD PTR i$[rbp]

; 37   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
skip_to	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT __v_lprintf
_TEXT	SEGMENT
len$ = 4
err$ = 36
s$ = 72
ptr$ = 104
flag$ = 132
n$ = 164
ch$ = 196
pad$ = 228
opt_long$ = 260
base$ = 292
width$ = 324
precision$ = 356
num$ = 392
prefix$ = 424
prefix_len$ = 452
tv150 = 660
tv80 = 660
tv189 = 664
tv163 = 664
tv81 = 664
__$ArrayPad$ = 672
format$ = 720
arg_ptr$ = 728
__v_lprintf PROC					; COMDAT

; 365  : {

$LN84:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 776				; 00000308H
	lea	rbp, QWORD PTR [rsp+80]
	lea	rdi, QWORD PTR [rsp+80]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+808]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 366  :     unsigned int len = 0;

	mov	DWORD PTR len$[rbp], 0

; 367  :     int err = errno;

	call	QWORD PTR __imp__errno
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR err$[rbp], eax
$LN73@v_lprintf:
$LN2@v_lprintf:

; 368  :     char *s;
; 369  :     unsigned char *ptr;
; 370  :     int flag;
; 371  :     signed int n;
; 372  :     unsigned char ch, pad;
; 373  :     
; 374  :     signed int opt_long;
; 375  : 
; 376  :     unsigned int base;
; 377  :     unsigned int width, precision;
; 378  :     
; 379  :     __int64 num;
; 380  :     char *prefix;
; 381  :     int prefix_len; /* 0x 0X 0 - + ' ' */
; 382  :     
; 383  :     while (*format) {

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@v_lprintf

; 384  :         
; 385  :         n = skip_to(format);

	mov	rcx, QWORD PTR format$[rbp]
	call	skip_to
	mov	DWORD PTR n$[rbp], eax

; 386  :         if (n) {

	cmp	DWORD PTR n$[rbp], 0
	je	SHORT $LN6@v_lprintf

; 387  :             output(format, n); 

	mov	edx, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	call	output

; 388  :             len += n;

	mov	eax, DWORD PTR n$[rbp]
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 389  :             format += n;

	movsxd	rax, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR format$[rbp], rax
$LN6@v_lprintf:

; 390  :         }
; 391  :         
; 392  :         if (*format != '%') 

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN7@v_lprintf

; 393  :             continue;

	jmp	SHORT $LN2@v_lprintf
$LN7@v_lprintf:

; 394  :         
; 395  :         pad = ' ';

	mov	BYTE PTR pad$[rbp], 32			; 00000020H

; 396  :         flag = 0;

	mov	DWORD PTR flag$[rbp], 0

; 397  :         opt_long = 0;

	mov	DWORD PTR opt_long$[rbp], 0

; 398  :         prefix_len = 0;

	mov	DWORD PTR prefix_len$[rbp], 0

; 399  :         prefix = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR prefix$[rbp], rax

; 400  :         
; 401  :         width = 0;

	mov	DWORD PTR width$[rbp], 0

; 402  :         precision = 0;

	mov	DWORD PTR precision$[rbp], 0

; 403  :         num = 0;

	mov	QWORD PTR num$[rbp], 0

; 404  :         
; 405  :         ++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax
$LN81@v_lprintf:
$LN80@v_lprintf:
$LN79@v_lprintf:
$LN78@v_lprintf:
$LN77@v_lprintf:
$LN76@v_lprintf:
$LN75@v_lprintf:
$LN74@v_lprintf:
$next_option$85:

; 406  :         
; 407  : next_option:
; 408  :         switch (ch = *format++) {

	mov	rax, QWORD PTR format$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rbp], al
	movzx	eax, BYTE PTR ch$[rbp]
	mov	DWORD PTR tv80[rbp], eax
	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax
	mov	eax, DWORD PTR tv80[rbp]
	mov	DWORD PTR tv81[rbp], eax
	cmp	DWORD PTR tv81[rbp], 122		; 0000007aH
	ja	$LN65@v_lprintf
	movsxd	rax, DWORD PTR tv81[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN82@v_lprintf[rcx+rax]
	mov	eax, DWORD PTR $LN83@v_lprintf[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN8@v_lprintf:

; 409  :         case 0:
; 410  :             return -1;

	mov	eax, -1
	jmp	$LN1@v_lprintf

; 411  :             break;

	jmp	$LN4@v_lprintf
$LN9@v_lprintf:

; 412  :             
; 413  :         /* FLAGS */
; 414  :         case '#':
; 415  :             flag |= F_HASH;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 4
	mov	DWORD PTR flag$[rbp], eax

; 416  :             goto next_option;

	jmp	$next_option$85
$LN10@v_lprintf:

; 417  : 
; 418  :         case 'h':
; 419  :             --opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	dec	eax
	mov	DWORD PTR opt_long$[rbp], eax

; 420  :             goto next_option;

	jmp	$LN74@v_lprintf
$LN11@v_lprintf:
$LN12@v_lprintf:

; 421  :             
; 422  :         case 'q':     
; 423  :         case 'L':
; 424  :             ++opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	inc	eax
	mov	DWORD PTR opt_long$[rbp], eax
$LN13@v_lprintf:
$LN14@v_lprintf:

; 425  :         case 'z':
; 426  :         case 'l':
; 427  :             ++opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	inc	eax
	mov	DWORD PTR opt_long$[rbp], eax

; 428  :             goto next_option;

	jmp	$LN75@v_lprintf
$LN15@v_lprintf:

; 429  :             
; 430  :         case '-':
; 431  :             flag |= F_LEFT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 8
	mov	DWORD PTR flag$[rbp], eax

; 432  :             goto next_option;

	jmp	$LN76@v_lprintf
$LN16@v_lprintf:

; 433  :             
; 434  :         case ' ':
; 435  :             flag |= F_SPACE;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 16
	mov	DWORD PTR flag$[rbp], eax

; 436  :             goto next_option;

	jmp	$LN77@v_lprintf
$LN17@v_lprintf:

; 437  :             
; 438  :         case '+':
; 439  :             flag |= F_PLUS;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR flag$[rbp], eax

; 440  :             goto next_option;

	jmp	$LN78@v_lprintf
$LN18@v_lprintf:
$LN19@v_lprintf:
$LN20@v_lprintf:
$LN21@v_lprintf:
$LN22@v_lprintf:
$LN23@v_lprintf:
$LN24@v_lprintf:
$LN25@v_lprintf:
$LN26@v_lprintf:
$LN27@v_lprintf:

; 441  :             
; 442  :         case '0':
; 443  :         case '1':
; 444  :         case '2':
; 445  :         case '3':
; 446  :         case '4':
; 447  :         case '5':
; 448  :         case '6':
; 449  :         case '7':
; 450  :         case '8':
; 451  :         case '9':
; 452  :             if (flag & F_DOT) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN28@v_lprintf

; 453  :                 return -1;

	mov	eax, -1
	jmp	$LN1@v_lprintf
$LN28@v_lprintf:

; 454  :             width = strtoul(format - 1, (char **)&s, 10);

	mov	rax, QWORD PTR format$[rbp]
	dec	rax
	mov	r8d, 10
	lea	rdx, QWORD PTR s$[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp_strtoul
	mov	DWORD PTR width$[rbp], eax

; 455  :             if (width > MAX_WIDTH) 

	cmp	DWORD PTR width$[rbp], 10240		; 00002800H
	jbe	SHORT $LN29@v_lprintf

; 456  :                 return -1;

	mov	eax, -1
	jmp	$LN1@v_lprintf
$LN29@v_lprintf:

; 457  :             if (ch == '0' && !(flag & F_LEFT)) 

	movzx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN30@v_lprintf
	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN30@v_lprintf

; 458  :                 pad = '0';

	mov	BYTE PTR pad$[rbp], 48			; 00000030H
$LN30@v_lprintf:

; 459  :             format = s;

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR format$[rbp], rax

; 460  :             goto next_option;

	jmp	$LN79@v_lprintf
$LN31@v_lprintf:

; 461  :             
; 462  :         case '*': 
; 463  :             if ((n = va_arg(arg_ptr, int)) < 0) {

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR n$[rbp], eax
	cmp	DWORD PTR n$[rbp], 0
	jge	SHORT $LN32@v_lprintf

; 464  :                 flag |= F_LEFT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 8
	mov	DWORD PTR flag$[rbp], eax

; 465  :                 n = -n;

	mov	eax, DWORD PTR n$[rbp]
	neg	eax
	mov	DWORD PTR n$[rbp], eax
$LN32@v_lprintf:

; 466  :             }
; 467  :             if ((width = (unsigned long)n) > MAX_WIDTH) 

	mov	eax, DWORD PTR n$[rbp]
	mov	DWORD PTR width$[rbp], eax
	cmp	DWORD PTR width$[rbp], 10240		; 00002800H
	jbe	SHORT $LN33@v_lprintf

; 468  :                 return -1;

	mov	eax, -1
	jmp	$LN1@v_lprintf
$LN33@v_lprintf:

; 469  :             goto next_option; 

	jmp	$LN80@v_lprintf
$LN34@v_lprintf:

; 470  :             
; 471  :         case '.':
; 472  :             flag |= F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR flag$[rbp], eax

; 473  :             if (*format == '*') {

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN35@v_lprintf

; 474  :                 n = va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR n$[rbp], eax

; 475  :                 ++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 476  :             } else {

	jmp	SHORT $LN36@v_lprintf
$LN35@v_lprintf:

; 477  :                 n = strtol(format, (char**)&s, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	call	QWORD PTR __imp_strtol
	mov	DWORD PTR n$[rbp], eax

; 478  :                 format = s;

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR format$[rbp], rax
$LN36@v_lprintf:

; 479  :             }
; 480  :             precision = n < 0 ? 0 : n;

	cmp	DWORD PTR n$[rbp], 0
	jge	SHORT $LN67@v_lprintf
	mov	DWORD PTR tv150[rbp], 0
	jmp	SHORT $LN68@v_lprintf
$LN67@v_lprintf:
	mov	eax, DWORD PTR n$[rbp]
	mov	DWORD PTR tv150[rbp], eax
$LN68@v_lprintf:
	mov	eax, DWORD PTR tv150[rbp]
	mov	DWORD PTR precision$[rbp], eax

; 481  :             if (precision > MAX_WIDTH) 

	cmp	DWORD PTR precision$[rbp], 10240	; 00002800H
	jbe	SHORT $LN37@v_lprintf

; 482  :                 return -1;

	mov	eax, -1
	jmp	$LN1@v_lprintf
$LN37@v_lprintf:

; 483  :             goto next_option;

	jmp	$LN81@v_lprintf
$LN38@v_lprintf:

; 484  :             
; 485  :         /* print a char or % */
; 486  :         case 'c':
; 487  :             ch = (char)va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movzx	eax, BYTE PTR [rax-8]
	mov	BYTE PTR ch$[rbp], al
$LN39@v_lprintf:

; 488  :         case '%':
; 489  :             output(&ch, 1); 

	mov	edx, 1
	lea	rcx, QWORD PTR ch$[rbp]
	call	output

; 490  :             ++len;

	mov	eax, DWORD PTR len$[rbp]
	inc	eax
	mov	DWORD PTR len$[rbp], eax

; 491  :             break;

	jmp	$LN4@v_lprintf
$LN40@v_lprintf:
$LN41@v_lprintf:

; 492  :                        
; 493  :         /* print a string */
; 494  :         case 'm':
; 495  :         case 's':
; 496  :             s = ch == 'm' ? strerror(err) : va_arg(arg_ptr, char *);

	movzx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN69@v_lprintf
	mov	ecx, DWORD PTR err$[rbp]
	call	QWORD PTR __imp_strerror
	mov	QWORD PTR tv163[rbp], rax
	jmp	SHORT $LN70@v_lprintf
$LN69@v_lprintf:
	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR tv163[rbp], rax
$LN70@v_lprintf:
	mov	rax, QWORD PTR tv163[rbp]
	mov	QWORD PTR s$[rbp], rax

; 497  :             if (s == NULL) 

	cmp	QWORD PTR s$[rbp], 0
	jne	SHORT $LN42@v_lprintf

; 498  :                 s = "(null)";

	lea	rax, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	mov	QWORD PTR s$[rbp], rax
$LN42@v_lprintf:

; 499  :             n = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	DWORD PTR n$[rbp], eax

; 500  :             if ((flag & F_DOT) && n > (signed)precision) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN43@v_lprintf
	mov	eax, DWORD PTR precision$[rbp]
	cmp	DWORD PTR n$[rbp], eax
	jle	SHORT $LN43@v_lprintf

; 501  :                 n = precision;

	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR n$[rbp], eax
$LN43@v_lprintf:

; 502  :             flag &= ~F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, -65				; ffffffffffffffbfH
	mov	DWORD PTR flag$[rbp], eax

; 503  :             len += output_string(s, n, 0, 

	mov	BYTE PTR [rsp+56], 32			; 00000020H
	mov	BYTE PTR [rsp+48], 32			; 00000020H
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 504  :                 width, 0, flag, ' ', ' ');
; 505  :             break;

	jmp	$LN4@v_lprintf
$LN44@v_lprintf:

; 506  :             
; 507  :         /* print an integer value */
; 508  :         case 'b':
; 509  :             base = 2;

	mov	DWORD PTR base$[rbp], 2

; 510  :             goto print_num;

	jmp	$print_num$86
$LN45@v_lprintf:

; 511  :             
; 512  :         case 'p':
; 513  :             prefix = "0x";

	lea	rax, OFFSET FLAT:??_C@_02MDDDDAID@0x@
	mov	QWORD PTR prefix$[rbp], rax

; 514  :             opt_long = sizeof(void *) / sizeof(long);

	mov	DWORD PTR opt_long$[rbp], 2
$LN46@v_lprintf:

; 515  :         case 'X':
; 516  :             if (ch == 'X')

	movzx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN47@v_lprintf

; 517  :                 flag |= F_UPCASE;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 2
	mov	DWORD PTR flag$[rbp], eax
$LN47@v_lprintf:
$LN48@v_lprintf:

; 518  :         case 'x':
; 519  :             base = 16;

	mov	DWORD PTR base$[rbp], 16

; 520  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN49@v_lprintf

; 521  :                 prefix = ch == 'X' ? "0X" : "0x";

	movzx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN71@v_lprintf
	lea	rax, OFFSET FLAT:??_C@_02FGLHBECB@0X@
	mov	QWORD PTR tv189[rbp], rax
	jmp	SHORT $LN72@v_lprintf
$LN71@v_lprintf:
	lea	rax, OFFSET FLAT:??_C@_02MDDDDAID@0x@
	mov	QWORD PTR tv189[rbp], rax
$LN72@v_lprintf:
	mov	rax, QWORD PTR tv189[rbp]
	mov	QWORD PTR prefix$[rbp], rax
$LN49@v_lprintf:

; 522  :             goto print_num;

	jmp	SHORT $print_num$86
$LN50@v_lprintf:
$LN51@v_lprintf:

; 523  :             
; 524  :         case 'd':
; 525  :         case 'i': 
; 526  :             flag |= F_SIGN;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 1
	mov	DWORD PTR flag$[rbp], eax
$LN52@v_lprintf:

; 527  :         case 'u':
; 528  :             base = 10;

	mov	DWORD PTR base$[rbp], 10

; 529  :             goto print_num;

	jmp	SHORT $print_num$86
$LN53@v_lprintf:

; 530  :             
; 531  :         case 'o':
; 532  :             base = 8;

	mov	DWORD PTR base$[rbp], 8

; 533  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN54@v_lprintf

; 534  :                 prefix = "0";

	lea	rax, OFFSET FLAT:??_C@_01GBGANLPD@0@
	mov	QWORD PTR prefix$[rbp], rax
$LN54@v_lprintf:
$print_num$86:

; 535  : print_num:
; 536  :             if (opt_long > 0) {

	cmp	DWORD PTR opt_long$[rbp], 0
	jle	SHORT $LN55@v_lprintf

; 537  :                 if (opt_long > 1)

	cmp	DWORD PTR opt_long$[rbp], 1
	jle	SHORT $LN57@v_lprintf

; 538  :                     num = va_arg(arg_ptr, __int64);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN58@v_lprintf
$LN57@v_lprintf:

; 539  :                 else
; 540  :                     num = (__int64)va_arg(arg_ptr, long);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movsxd	rax, DWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
$LN58@v_lprintf:

; 541  :             } else 

	jmp	SHORT $LN56@v_lprintf
$LN55@v_lprintf:

; 542  :                 num = (__int64)va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movsxd	rax, DWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
$LN56@v_lprintf:

; 543  : 
; 544  :             len += output_integer(num, opt_long, ch, 

	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+64], al
	mov	rax, QWORD PTR prefix$[rbp]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR base$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR precision$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR width$[rbp]
	movzx	r8d, BYTE PTR ch$[rbp]
	mov	edx, DWORD PTR opt_long$[rbp]
	mov	rcx, QWORD PTR num$[rbp]
	call	output_integer
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 545  :                 width, precision, flag, base, prefix, pad);
; 546  :             break;

	jmp	$LN4@v_lprintf
$LN59@v_lprintf:
$LN60@v_lprintf:
$LN61@v_lprintf:
$LN62@v_lprintf:
$LN63@v_lprintf:

; 547  :   
; 548  :         /* print a floating point value */
; 549  :         case 'g':
; 550  :         case 'F':  
; 551  :         case 'f':
; 552  :         case 'e':
; 553  :         case 'E':
; 554  :             len += output_double(va_arg(arg_ptr, double), ch, 

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	movzx	eax, BYTE PTR pad$[rbp]
	mov	rcx, QWORD PTR arg_ptr$[rbp]
	movsd	xmm0, QWORD PTR [rcx-8]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR precision$[rbp]
	mov	r8d, DWORD PTR width$[rbp]
	movzx	edx, BYTE PTR ch$[rbp]
	call	output_double
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax

; 555  :                 width, precision, flag, pad);
; 556  :             break;

	jmp	SHORT $LN4@v_lprintf
$LN64@v_lprintf:

; 557  : 
; 558  :         /* print a memory block */
; 559  :         case 'M': 
; 560  :             ptr = va_arg(arg_ptr, unsigned char *);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR ptr$[rbp], rax

; 561  :             len += output_memory_block(ptr, va_arg(arg_ptr, int), 

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	movzx	eax, BYTE PTR pad$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR precision$[rbp]
	mov	r8d, DWORD PTR width$[rbp]
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	edx, DWORD PTR [rax-8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	output_memory_block
	mov	ecx, DWORD PTR len$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$[rbp], eax
$LN65@v_lprintf:
$LN4@v_lprintf:

; 562  :                 width, precision, flag, pad); 
; 563  :             break; 
; 564  : 
; 565  :         default:
; 566  :             break;
; 567  :         }
; 568  :     }

	jmp	$LN73@v_lprintf
$LN3@v_lprintf:

; 569  :     return len;

	mov	eax, DWORD PTR len$[rbp]
$LN1@v_lprintf:

; 570  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-80]
	lea	rdx, OFFSET FLAT:__v_lprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+696]
	pop	rdi
	pop	rbp
	ret	0
	npad	2
$LN83@v_lprintf:
	DD	$LN8@v_lprintf
	DD	$LN16@v_lprintf
	DD	$LN9@v_lprintf
	DD	$LN39@v_lprintf
	DD	$LN31@v_lprintf
	DD	$LN17@v_lprintf
	DD	$LN15@v_lprintf
	DD	$LN34@v_lprintf
	DD	$LN18@v_lprintf
	DD	$LN19@v_lprintf
	DD	$LN20@v_lprintf
	DD	$LN21@v_lprintf
	DD	$LN22@v_lprintf
	DD	$LN23@v_lprintf
	DD	$LN24@v_lprintf
	DD	$LN25@v_lprintf
	DD	$LN26@v_lprintf
	DD	$LN27@v_lprintf
	DD	$LN63@v_lprintf
	DD	$LN60@v_lprintf
	DD	$LN12@v_lprintf
	DD	$LN64@v_lprintf
	DD	$LN46@v_lprintf
	DD	$LN44@v_lprintf
	DD	$LN38@v_lprintf
	DD	$LN50@v_lprintf
	DD	$LN62@v_lprintf
	DD	$LN61@v_lprintf
	DD	$LN59@v_lprintf
	DD	$LN10@v_lprintf
	DD	$LN51@v_lprintf
	DD	$LN14@v_lprintf
	DD	$LN40@v_lprintf
	DD	$LN53@v_lprintf
	DD	$LN45@v_lprintf
	DD	$LN11@v_lprintf
	DD	$LN41@v_lprintf
	DD	$LN52@v_lprintf
	DD	$LN48@v_lprintf
	DD	$LN13@v_lprintf
	DD	$LN65@v_lprintf
$LN82@v_lprintf:
	DB	0
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	1
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	2
	DB	40					; 00000028H
	DB	3
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	4
	DB	5
	DB	40					; 00000028H
	DB	6
	DB	7
	DB	40					; 00000028H
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	16
	DB	17
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	18
	DB	19
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	20
	DB	21
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	22
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	23
	DB	24
	DB	25
	DB	26
	DB	27
	DB	28
	DB	29
	DB	30
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	31
	DB	32					; 00000020H
	DB	40					; 00000028H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	40					; 00000028H
	DB	36					; 00000024H
	DB	40					; 00000028H
	DB	37					; 00000025H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	38					; 00000026H
	DB	40					; 00000028H
	DB	39					; 00000027H
__v_lprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Cproject\NETLab1-Windows-VS2019exp\lprintf.c
;	COMDAT lprintf
_TEXT	SEGMENT
n$ = 4
arg_ptr$ = 40
__$ArrayPad$ = 248
format$ = 288
lprintf	PROC						; COMDAT

; 573  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__3ED4F62B_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 574  :     int n;
; 575  :     va_list arg_ptr;
; 576  : 
; 577  :     va_start(arg_ptr, format);

	lea	rax, QWORD PTR format$[rbp+8]
	mov	QWORD PTR arg_ptr$[rbp], rax

; 578  : 	n = __v_lprintf(format, arg_ptr);

	mov	rdx, QWORD PTR arg_ptr$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	call	__v_lprintf
	mov	DWORD PTR n$[rbp], eax

; 579  :     va_end(arg_ptr);

	mov	QWORD PTR arg_ptr$[rbp], 0

; 580  : 
; 581  :     return n;

	mov	eax, DWORD PTR n$[rbp]

; 582  : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:lprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
lprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Buffer$ = 288
_Format$ = 296
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 1780 :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsnprintf_l

; 1460 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 4
tv74 = 212
_Buffer$ = 256
_BufferCount$ = 264
_Format$ = 272
_Locale$ = 280
_ArgList$ = 288
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rbp]
	mov	r8, QWORD PTR _BufferCount$[rbp]
	mov	rdx, QWORD PTR _Buffer$[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rbp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rbp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rbp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rbp]
	mov	DWORD PTR tv74[rbp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rbp]

; 1397 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A2143F22_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
